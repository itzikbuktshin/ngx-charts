{"version":3,"sources":["/home/runner/work/ngx-charts/ngx-charts/dist/ngx-charts/fesm2015/ngx-charts.js","./$_lazy_route_resource lazy namespace object","./src/app/app-routing.module.ts","./src/app/app.component.ts","./src/app/app.component.html","./src/app/app.module.ts","./src/app/components/bubble-chart/bubble-chart.component.ts","./src/app/components/bubble-chart/bubble-chart.component.html","./src/app/components/bubble-chart/bubble-chart.module.ts","./src/app/components/components.module.ts","./src/environments/environment.ts","./src/main.ts"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiU;AAClS;AACgB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA,0BAA0B;AAC1B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD,uCAAuC,mBAAmB;AAC1D;AACA;AACA,uCAAuC,qBAAqB;AAC5D;AACA;AACA;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,SAAS,GAAG,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS,KAAK,SAAS;AAC/C;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA,KAAK;AACL;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,4CAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB,mBAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,iCAAiC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,MAAK,IAAI,KAA0F;AAC3G,QAAQ,MAAK,IAAI,KAA2F;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,uB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","file":"main.js","sourcesContent":["import { ɵɵdefineInjectable, ɵsetClassMetadata, Injectable, ɵɵdirectiveInject, ɵɵdefineComponent, ɵɵviewQuery, ɵɵqueryRefresh, ɵɵloadQuery, ɵɵelementStart, ɵɵelement, ɵɵelementEnd, ɵɵadvance, ɵɵproperty, Component, ViewChild, Input, ɵɵdefineNgModule, ɵɵdefineInjector, ɵɵsetNgModuleScope, NgModule } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { CommonModule } from '@angular/common';\n\nclass Circle {\n    constructor(radius, center, selected) {\n        this.selected = false;\n        this.radius = radius;\n        this.center = center;\n        this.selected = selected;\n    }\n    get geo() {\n        return {\n            cx: this.center.x,\n            cy: this.center.y,\n            r: this.radius\n        };\n    }\n    surface() {\n        return Math.PI * this.radius * this.radius;\n    }\n    distance(circle) {\n        return this.center.dist(circle.center) - this.radius - circle.radius;\n    }\n}\n\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    dist(p) {\n        return this.vect(p).norm();\n    }\n    vect(p) {\n        return new Point(p.x - this.x, p.y - this.y);\n    }\n    norm() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    add(v) {\n        return new Point(this.x + v.x, this.y + v.y);\n    }\n    mult(a) {\n        return new Point(this.x * a, this.y * a);\n    }\n    inCircle(cx, cy, radius) {\n        const dx = cx - this.x;\n        const dy = cy - this.y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        return dist < radius;\n    }\n}\n\nclass Packer {\n    constructor(radiuses, ratio, circles) {\n        this.radiuses = radiuses;\n        this.ratio = ratio || 1;\n        this.list = circles || this.solve();\n    }\n    compute(surface) {\n        const bounding_r = Math.sqrt(surface) * 100;\n        const w = (this.width = Math.sqrt(surface * this.ratio));\n        const h = (this.height = this.width / this.ratio);\n        const in_rect = (radius, center) => {\n            if (center.x - radius < -w / 2)\n                return false;\n            if (center.x + radius > w / 2)\n                return false;\n            if (center.y - radius < -h / 2)\n                return false;\n            if (center.y + radius > h / 2)\n                return false;\n            return true;\n        };\n        // approximate a segment with an \"infinite\" radius circle\n        const bounding_circle = (x0, y0, x1, y1) => {\n            const xm = Math.abs((x1 - x0) * w);\n            const ym = Math.abs((y1 - y0) * h);\n            const m = xm > ym ? xm : ym;\n            const theta = Math.asin(m / 4 / bounding_r);\n            const r = bounding_r * Math.cos(theta);\n            return new Circle(bounding_r, new Point((r * (y0 - y1)) / 2 + ((x0 + x1) * w) / 4, (r * (x1 - x0)) / 2 + ((y0 + y1) * h) / 4));\n        };\n        // return the corner placements for two circles\n        const corner = (radius, c1, c2) => {\n            let u = c1.center.vect(c2.center); // c1 to c2 vector\n            const A = u.norm();\n            if (A == 0)\n                return []; // same centers\n            u = u.mult(1 / A); // c1 to c2 unary vector\n            // compute c1 and c2 intersection coordinates in (u,v) base\n            const B = c1.radius + radius;\n            const C = c2.radius + radius;\n            if (A > B + C)\n                return []; // too far apart\n            const x = (A + (B * B - C * C) / A) / 2;\n            const y = Math.sqrt(B * B - x * x);\n            const base = c1.center.add(u.mult(x));\n            const res = [];\n            const p1 = new Point(base.x - u.y * y, base.y + u.x * y);\n            const p2 = new Point(base.x + u.y * y, base.y - u.x * y);\n            if (in_rect(radius, p1))\n                res.push(new Circle(radius, p1));\n            if (in_rect(radius, p2))\n                res.push(new Circle(radius, p2));\n            return res;\n        };\n        // place our bounding circles\n        const placed = [\n            bounding_circle(1, 1, 1, -1),\n            bounding_circle(1, -1, -1, -1),\n            bounding_circle(-1, -1, -1, 1),\n            bounding_circle(-1, 1, 1, 1)\n        ];\n        // Initialize our rectangles list\n        const unplaced = this.radiuses.slice(0); // clones the array\n        while (unplaced.length > 0) {\n            // compute all possible placements of the unplaced circles\n            const lambda = {};\n            const circle = {};\n            for (let i = 0; i != unplaced.length; i++) {\n                let lambda_min = 1e10;\n                lambda[i] = -1e10;\n                // match current circle against all possible pairs of placed circles\n                for (let j = 0; j < placed.length; j++)\n                    for (let k = j + 1; k < placed.length; k++) {\n                        const corners = corner(unplaced[i], placed[j], placed[k]);\n                        // check each placement\n                        for (let c = 0; c != corners.length; c++) {\n                            // check for overlap and compute min distance\n                            let d_min = 1e10;\n                            let l = 0;\n                            for (; l != placed.length; l++) {\n                                // skip the two circles used for the placement\n                                if (l == j || l == k)\n                                    continue;\n                                // compute distance from current circle\n                                const d = placed[l].distance(corners[c]);\n                                if (d < 0)\n                                    break; // circles overlap\n                                if (d < d_min)\n                                    d_min = d;\n                            }\n                            if (l == placed.length) {\n                                // no overlap\n                                if (d_min < lambda_min) {\n                                    lambda_min = d_min;\n                                    lambda[i] = 1 - d_min / unplaced[i];\n                                    circle[i] = corners[c];\n                                }\n                            }\n                        }\n                    }\n            }\n            // select the circle with maximal gain\n            let lambda_max = -1e10;\n            let i_max = -1;\n            for (let i = 0; i != unplaced.length; i++) {\n                if (lambda[i] > lambda_max) {\n                    lambda_max = lambda[i];\n                    i_max = i;\n                }\n            }\n            // failure if no circle fits\n            if (i_max == -1)\n                break;\n            // place the selected circle\n            unplaced.splice(i_max, 1);\n            placed.push(circle[i_max]);\n        }\n        // return all placed circles except the four bounding circles\n        this.tmpBounds = placed.splice(0, 4);\n        return placed;\n    }\n    solve() {\n        let surface = 0;\n        for (let i = 0; i != this.radiuses.length; i++) {\n            surface += Math.PI * Math.pow(this.radiuses[i], 2);\n        }\n        // set a suitable precision\n        const limit = surface / 1000;\n        let step = surface / 2;\n        let res = [];\n        while (step > limit) {\n            const placement = this.compute(surface);\n            if (placement.length != this.radiuses.length) {\n                surface += step;\n            }\n            else {\n                res = placement;\n                this.bounds = this.tmpBounds;\n                surface -= step;\n            }\n            step /= 2;\n        }\n        return res;\n    }\n}\n\nfunction getFont(fontSize = '12px', fontName = 'Helvetica') {\n    return `${fontSize} ${fontName}`;\n}\nfunction wrapTextInCircle(ctx, text, circle, textHeight, fontName, fontSize, textColor, paddingX = 20) {\n    if (!text)\n        return;\n    let index = 0;\n    let textRows = [];\n    const words = text.split(\" \");\n    const font = `500 ${fontSize}px ${fontName}`;\n    const lineHeight = textHeight + 7;\n    const { cx, cy, r } = circle.geo;\n    const circleDiameter = 2 * r;\n    const y0 = cy - r;\n    const initTextLines = () => {\n        const lines = [];\n        for (let y = r; y > -r; y -= lineHeight) {\n            let height = Math.abs(r - y);\n            const length = 2 * Math.sqrt(height * (circleDiameter - height));\n            if (length && length > 10) {\n                const maxLength = (length + paddingX >= circleDiameter) ? length - paddingX : length;\n                lines.push({ y, maxLength });\n            }\n        }\n        return lines;\n    };\n    // calculate how many words will fit on a line\n    const calcAllowableWords = (maxWidth, words) => {\n        let testLine = \"\";\n        let spacer = \"\";\n        let fittedWidth = 0;\n        let fittedText = \"\";\n        let width = 0;\n        ctx.font = font;\n        for (let i = 0; i < words.length; i++) {\n            testLine += spacer + words[i];\n            spacer = \" \";\n            width = ctx.measureText(testLine).width;\n            if (width > maxWidth) {\n                return ({\n                    count: i,\n                    width: fittedWidth,\n                    text: fittedText\n                });\n            }\n            fittedWidth = width;\n            fittedText = testLine;\n        }\n        return {\n            count: words.length,\n            width: width,\n            text: testLine,\n        };\n    };\n    const textLines = initTextLines();\n    while (index < textLines.length && words.length > 0) {\n        const line = textLines[index++];\n        const lineData = calcAllowableWords(line.maxLength, words);\n        let lineWords = words.splice(0, lineData.count);\n        let textLine = lineWords.join(\" \");\n        const textLineData = {\n            lineData,\n            line,\n            textLine\n        };\n        textRows.push(textLineData);\n    }\n    ;\n    const placedWords = textRows.map(({ lineData }) => lineData.count).reduce((prev, next) => prev + next);\n    const unplacedWords = text.split(\" \").length - placedWords;\n    if (unplacedWords > 0) {\n        // scale font size\n        return this.wrapTextInCircle(ctx, text, circle, textHeight, fontName, fontSize -= 1, textColor);\n    }\n    const placedRows = textRows.filter(({ lineData }) => {\n        return lineData.count !== 0;\n    });\n    const textBoxHeight = placedRows.length * lineHeight;\n    const topPadding = ((circleDiameter - textBoxHeight) / 2);\n    ctx.fillStyle = textColor;\n    placedRows.forEach(({ lineData, textLine }, index) => {\n        let x = cx - lineData.width / 2;\n        let y = (y0 + topPadding) + (lineHeight * (index + 1));\n        ctx.fillText(textLine, x, y);\n    });\n}\nfunction drawImage(ctx, src, imageWidth, imageHeight, dx, dy, text, textColor = '') {\n    let image = null;\n    const space = !!text ? 5 : 0;\n    if (!!text) {\n        const txtSize = ctx.measureText(text);\n        const blockSize = imageWidth + space + txtSize.width;\n        dx = dx - (blockSize / 2);\n        this.fillText(ctx, text, textColor, (dx + space + imageWidth), dy + imageHeight);\n    }\n    image = new Image(imageWidth, imageHeight);\n    image.src = src;\n    image.onload = () => {\n        ctx.drawImage(image, dx, dy);\n    };\n}\nfunction fillText(ctx, text, textColor, dx, dy, maxWidth, fontSize = '12px', fontName = 'Helvetica') {\n    const txtSize = ctx.measureText(text);\n    ctx.fillStyle = textColor;\n    ctx.font = this.getFont(fontSize, fontName);\n    ctx.fillText(text, dx, dy, maxWidth || txtSize.width);\n    return txtSize.width;\n}\n\nclass NgxBubbleChartService {\n    constructor() {\n        this._bubbleSelectedSubject = new Subject();\n        this._circlels = [];\n        this._margin = 0.85;\n        this._marginFactor = 0;\n    }\n    get bubbleSelected$() {\n        return this._bubbleSelectedSubject.asObservable();\n    }\n    draw(bubbles, width, height, minRadius, maxRadius, chartElm) {\n        this._circlels = [];\n        let bubblesCircles;\n        const radiuses = this.getRadiuses(bubbles, minRadius, maxRadius);\n        this._canvasWidth = width;\n        this._canvasHeight = height;\n        const ratio = this._canvasWidth / this._canvasHeight;\n        const canvas = chartElm.nativeElement;\n        bubbles.forEach(({ circleRef }) => {\n            if (!circleRef)\n                return;\n            if (!bubblesCircles)\n                bubblesCircles = [];\n            bubblesCircles.push(circleRef);\n        });\n        const packer = new Packer(radiuses, ratio, bubblesCircles);\n        packer.mx = (width * this._marginFactor) / 2;\n        packer.my = (height * this._marginFactor) / 2;\n        packer.dx = packer.width / 2;\n        packer.dy = packer.height / 2;\n        this.drawResult(packer, canvas, bubbles);\n        this.listenToClickEvents(canvas, packer);\n    }\n    drawCircle(circle, ctx, packer) {\n        const color = circle.selected ? \"#1300ab\" : \"#e5e5e5\";\n        const fontName = 'Helvetica';\n        const paddingBottom = 20;\n        const { countOther, value } = circle.data || { countOther: 1, value: '' };\n        if (!value)\n            return;\n        const cx = (circle.center.x + packer.dx) * packer.zoom + packer.mx;\n        const cy = (circle.center.y + packer.dy) * packer.zoom + packer.my;\n        const r = circle.radius * packer.zoom * this._margin;\n        const textColor = circle.selected ? \"#ffffff\" : \"#737373\";\n        const imageSrc = `assets/images/person-user${circle.selected ? '-active' : ''}-icon.svg`;\n        ctx.beginPath();\n        ctx.arc(cx, cy, r, 0, 2 * Math.PI);\n        ctx.fillStyle = color;\n        ctx.fill();\n        ctx.strokeStyle = '#e5e5e5';\n        ctx.stroke();\n        false && drawImage(ctx, imageSrc, 12, 12, cx, (cy + r) - paddingBottom, `${countOther}`, textColor);\n        false && wrapTextInCircle(ctx, value, new Circle(r, new Point(cx, cy)), 10, fontName, 16, textColor);\n        ctx.closePath();\n    }\n    ;\n    drawResult(packer, canvas, bubbles) {\n        const ctx = canvas.getContext('2d');\n        ctx.canvas.width = this._canvasWidth;\n        ctx.canvas.height = this._canvasHeight;\n        const zx = (canvas.width * (1 - this._marginFactor)) / packer.width;\n        const zy = (canvas.height * (1 - this._marginFactor)) / packer.height;\n        packer.zoom = zx < zy ? zx : zy;\n        const sortedCircles = packer.list.sort((a, b) => (a.radius > b.radius ? -1 : 1));\n        sortedCircles.forEach((circle, index) => {\n            const { id, selected, value } = bubbles[index];\n            circle.id = id;\n            circle.data = {\n                value\n            };\n            const bubble = bubbles.find((bubble) => bubble.id === id);\n            bubble.circleRef = circle;\n            circle.selected = selected;\n            this.drawCircle(circle, ctx, packer);\n            this._circlels.push(circle);\n        });\n        // draw bounding circles\n        for (var i = 0; i != packer.bounds.length; i++) {\n            this.drawCircle(packer.bounds[i], ctx, packer);\n        }\n        ctx.beginPath();\n        ctx.rect((-packer.width / 2 + packer.dx) * packer.zoom + packer.mx, (-packer.height / 2 + packer.dy) * packer.zoom + packer.my, packer.width * packer.zoom, packer.height * packer.zoom);\n        ctx.closePath();\n    }\n    getRadiuses(bubbles, minRadius, maxRadius) {\n        const radiuses = [];\n        let min = Number.MAX_VALUE;\n        let max = Number.MIN_VALUE;\n        bubbles.forEach((bubble) => {\n            if (bubble.value > max) {\n                max = bubble.value;\n            }\n            else if (bubble.value < min) {\n                min = bubble.value;\n            }\n        });\n        bubbles.forEach((bubble) => {\n            const { value } = bubble;\n            const radius = (((value - min) / (max - min)) * (maxRadius - minRadius)) + minRadius;\n            radiuses.push(radius);\n        });\n        return radiuses;\n    }\n    isPointInCircle(circle, point, packer) {\n        const { radius } = circle;\n        const cx = (circle.center.x + packer.dx) * packer.zoom + packer.mx;\n        const cy = (circle.center.y + packer.dy) * packer.zoom + packer.my;\n        return point.inCircle(cx, cy, radius * packer.zoom * this._margin);\n    }\n    listenToClickEvents(canvas, packer) {\n        const ctx = canvas.getContext('2d');\n        canvas.addEventListener(\"click\", (event) => {\n            let clikedPoint = new Point(event.offsetX, event.offsetY);\n            this._circlels.forEach((circle) => {\n                if (!this.isPointInCircle(circle, clikedPoint, packer))\n                    return;\n                this._bubbleSelectedSubject.next(circle.id);\n                circle.selected = !circle.selected;\n                this.drawCircle(circle, ctx, packer);\n            });\n        }, true);\n    }\n}\nNgxBubbleChartService.ɵfac = function NgxBubbleChartService_Factory(t) { return new (t || NgxBubbleChartService)(); };\nNgxBubbleChartService.ɵprov = ɵɵdefineInjectable({ token: NgxBubbleChartService, factory: NgxBubbleChartService.ɵfac });\n/*@__PURE__*/ (function () { ɵsetClassMetadata(NgxBubbleChartService, [{\n        type: Injectable\n    }], null, null); })();\n\nconst _c0 = [\"bubbleChart\"];\nclass NgxBubbleChartComponent {\n    constructor(bubbleChartService) {\n        this.bubbleChartService = bubbleChartService;\n        this.id = `ngx-bubble-chart-${NgxBubbleChartComponent.Id++}`;\n    }\n    set chart(chart) {\n        var _a;\n        const bubbles = (_a = chart === null || chart === void 0 ? void 0 : chart.bubbles) === null || _a === void 0 ? void 0 : _a.map((bubble) => {\n            var _a;\n            return Object.assign(Object.assign({}, bubble), { selected: (_a = chart === null || chart === void 0 ? void 0 : chart.selectedBubbles) === null || _a === void 0 ? void 0 : _a.includes(bubble.id) });\n        });\n        const bubbleChart = Object.assign(Object.assign({}, chart), { bubbles });\n        this.draw(bubbleChart);\n    }\n    draw(bubbleChart) {\n        const isMobile = false;\n        const minRadius = isMobile ? 45 : 35;\n        const maxRadius = isMobile ? 80 : 90;\n        setTimeout(() => {\n            this.bubbleChartService.draw(bubbleChart.bubbles, bubbleChart.options.width, bubbleChart.options.height, minRadius, maxRadius, this.chartElm);\n        }, 0);\n    }\n}\nNgxBubbleChartComponent.Id = 0;\nNgxBubbleChartComponent.ɵfac = function NgxBubbleChartComponent_Factory(t) { return new (t || NgxBubbleChartComponent)(ɵɵdirectiveInject(NgxBubbleChartService)); };\nNgxBubbleChartComponent.ɵcmp = ɵɵdefineComponent({ type: NgxBubbleChartComponent, selectors: [[\"ngx-charts-ngx-bubble-chart\"]], viewQuery: function NgxBubbleChartComponent_Query(rf, ctx) { if (rf & 1) {\n        ɵɵviewQuery(_c0, true);\n    } if (rf & 2) {\n        var _t;\n        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.chartElm = _t.first);\n    } }, inputs: { chart: \"chart\" }, decls: 4, vars: 1, consts: [[1, \"bubbleChart\"], [3, \"id\"], [\"bubbleChart\", \"\"]], template: function NgxBubbleChartComponent_Template(rf, ctx) { if (rf & 1) {\n        ɵɵelementStart(0, \"div\", 0);\n        ɵɵelement(1, \"canvas\", 1, 2);\n        ɵɵelement(3, \"div\");\n        ɵɵelementEnd();\n    } if (rf & 2) {\n        ɵɵadvance(1);\n        ɵɵproperty(\"id\", ctx.id);\n    } }, styles: [\".bubbleChart[_ngcontent-%COMP%], [_nghost-%COMP%]{height:100%;width:100%}\"] });\n/*@__PURE__*/ (function () { ɵsetClassMetadata(NgxBubbleChartComponent, [{\n        type: Component,\n        args: [{\n                selector: 'ngx-charts-ngx-bubble-chart',\n                templateUrl: './ngx-bubble-chart.component.html',\n                styleUrls: ['./ngx-bubble-chart.component.scss']\n            }]\n    }], function () { return [{ type: NgxBubbleChartService }]; }, { chartElm: [{\n            type: ViewChild,\n            args: ['bubbleChart']\n        }], chart: [{\n            type: Input\n        }] }); })();\n\nclass NgxBubbleChartModule {\n}\nNgxBubbleChartModule.ɵmod = ɵɵdefineNgModule({ type: NgxBubbleChartModule });\nNgxBubbleChartModule.ɵinj = ɵɵdefineInjector({ factory: function NgxBubbleChartModule_Factory(t) { return new (t || NgxBubbleChartModule)(); }, providers: [NgxBubbleChartService], imports: [[\n            CommonModule\n        ]] });\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵɵsetNgModuleScope(NgxBubbleChartModule, { declarations: [NgxBubbleChartComponent], imports: [CommonModule], exports: [NgxBubbleChartComponent] }); })();\n/*@__PURE__*/ (function () { ɵsetClassMetadata(NgxBubbleChartModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [NgxBubbleChartComponent],\n                imports: [\n                    CommonModule\n                ],\n                providers: [NgxBubbleChartService],\n                exports: [NgxBubbleChartComponent]\n            }]\n    }], null, null); })();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgxBubbleChartComponent, NgxBubbleChartModule };\n//# sourceMappingURL=ngx-charts.js.map\n","function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(function() {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = function() { return []; };\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nmodule.exports = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = \"./$$_lazy_route_resource lazy recursive\";","import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { BubbleChartComponent } from './components/bubble-chart/bubble-chart.component';\n\nconst routes: Routes = [\n  {\n    path:'',\n    redirectTo: 'bubbles',\n    pathMatch: 'full'\n  },\n  {\n    path: 'bubbles',\n    component: BubbleChartComponent\n  }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'demo-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\nexport class AppComponent {\n  title = 'demo';\n}\n","<div class=\"content\">\n    <span>{{title}} app is running!</span>\n</div>\n<router-outlet></router-outlet>","import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { NgxBubbleChartModule } from 'ngx-charts';\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { ComponentsModule } from \"./components/components.module\";\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    ComponentsModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n","import { Component } from '@angular/core';\nimport { NgxBubbleChart } from \"ngx-charts\";\n\n@Component({\n  selector: 'demo-bubble-chart',\n  templateUrl: './bubble-chart.component.html',\n  styleUrls: ['./bubble-chart.component.scss']\n})\nexport class BubbleChartComponent {\n\n  public bubbleChart: NgxBubbleChart = {\n    options: {\n      width: 500,\n      height: 500\n    },\n    selectedBubbles: [1],\n    bubbles: [\n      { id: 1, value: 10 },\n      { id: 2, value: 30 },\n      { id: 3, value: 20 },\n      { id: 4, value: 8 },\n      { id: 5, value: 15 },\n      { id: 6, value: 7 },\n      { id: 7, value: 7 },\n      { id: 8, value: 104 },\n      { id: 9, value: 140 },\n    ]\n  }\n\n  add(): void {\n    const nextId = this.getNextId();\n    const bubbles = [\n      ...this.bubbleChart.bubbles,\n      {\n        id: nextId,\n        value: 55\n      }\n    ]\n    this.refreshChart(bubbles);\n  }\n\n  remove(): void {\n    const lestId = this.getLastAdded();\n    if (!lestId) return;\n\n    const bubbles = [\n      ...this.bubbleChart.bubbles.filter((b) => b.id !== lestId)\n    ]\n    this.refreshChart(bubbles);\n  }\n\n  private getNextId(): number {\n    const maxId = this.getLastAdded() || 0;\n    return maxId + 1;\n  }\n\n  private getLastAdded(): number {\n    const [max] = this.bubbleChart.bubbles.sort((a, b) => (a.id > b.id ? 1 : -1))\n    return max?.id;\n  }\n\n  private refreshChart(bubbles): void {\n    this.bubbleChart = {\n      ...this.bubbleChart,\n      bubbles\n    };\n  }\n}","<button (click)=\"add()\">Add</button>\n<button (click)=\"remove()\">Remove</button>\n<ngx-charts-ngx-bubble-chart [chart]=\"bubbleChart\"></ngx-charts-ngx-bubble-chart>","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { NgxBubbleChartModule } from 'ngx-charts';\nimport { BubbleChartComponent } from \"./bubble-chart.component\";\n\n@NgModule({\n  declarations: [BubbleChartComponent],\n  imports: [\n    CommonModule,\n    NgxBubbleChartModule\n  ],\n  exports: [BubbleChartComponent]\n})\nexport class BubbleChartModule { }\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { BubbleChartModule } from './bubble-chart/bubble-chart.module';\n\n@NgModule({\n  declarations: [],\n  imports: [\n    CommonModule,\n    BubbleChartModule\n  ],\n  exports:[BubbleChartModule ]\n})\nexport class ComponentsModule { }","// This file can be replaced during build by using the `fileReplacements` array.\n// `ng build --prod` replaces `environment.ts` with `environment.prod.ts`.\n// The list of file replacements can be found in `angular.json`.\n\nexport const environment = {\n  production: false\n};\n\n/*\n * For easier debugging in development mode, you can import the following file\n * to ignore zone related error stack frames such as `zone.run`, `zoneDelegate.invokeTask`.\n *\n * This import should be commented out in production mode because it will have a negative impact\n * on performance if an error is thrown.\n */\n// import 'zone.js/dist/zone-error';  // Included with Angular CLI.\n","import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n"],"sourceRoot":"webpack:///"}